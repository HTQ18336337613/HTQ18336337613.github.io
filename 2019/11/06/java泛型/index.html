<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>java泛型 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java 泛型Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的">
<meta property="og:type" content="article">
<meta property="og:title" content="java泛型">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;06&#x2F;java%E6%B3%9B%E5%9E%8B&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java 泛型Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-11-06T11:09:19.732Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/06/java%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time datetime="2019-11-06T11:08:56.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java泛型
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java 泛型<br>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？</p>
<p>答案是可以使用 Java 泛型。</p>
<p>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。<br>泛型方法<br>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p>
<p>下面是定义泛型方法的规则：</p>
<p>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的）。<br>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。<br>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。<br>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。<br>实例</p>
<p>下面的例子演示了如何使用泛型方法打印不同字符串的元素：</p>
<p>实例<br>public class GenericMethodTest { // 泛型方法 printArray public static &lt; E &gt; void printArray( E[] inputArray ) { // 输出数组元素 for ( E element : inputArray ){ System.out.printf( “%s “, element ); } System.out.println(); } public static void main( String args[] ) { // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = { 1, 2, 3, 4, 5 }; Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; Character[] charArray = { ‘H’, ‘E’, ‘L’, ‘L’, ‘O’ }; System.out.println( “整型数组元素为:” ); printArray( intArray ); // 传递一个整型数组 System.out.println( “\n双精度型数组元素为:” ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( “\n字符型数组元素为:” ); printArray( charArray ); // 传递一个字符型数组 } }</p>
<p>编译以上代码，运行结果如下所示：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>整型数组元素为:<br>1 2 3 4 5 </p>
<p>双精度型数组元素为:<br>1.1 2.2 3.3 4.4 </p>
<p>字符型数组元素为:<br>H E L L O<br>有界的类型参数:</p>
<p>可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。</p>
<p>要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。</p>
<p>实例</p>
<p>下面的例子演示了”extends”如何使用在一般意义上的意思”extends”（类）或者”implements”（接口）。该例子中的泛型方法返回三个可比较对象的最大值。</p>
<p>实例<br>public class MaximumTest { // 比较三个值并返回最大值 public static <T extends Comparable> T maximum(T x, T y, T z) { T max = x; // 假设x是初始最大值 if ( y.compareTo( max ) &gt; 0 ){ max = y; //y 更大 } if ( z.compareTo( max ) &gt; 0 ){ max = z; // 现在 z 更大 } return max; // 返回最大对象 } public static void main( String args[] ) { System.out.printf( “%d, %d 和 %d 中最大的数为 %d\n\n”, 3, 4, 5, maximum( 3, 4, 5 ) ); System.out.printf( “%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n”, 6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) ); System.out.printf( “%s, %s 和 %s 中最大的数为 %s\n”,”pear”, “apple”, “orange”, maximum( “pear”, “apple”, “orange” ) ); } }</p>
<p>编译以上代码，运行结果如下所示：</p>
<p>1<br>2<br>3<br>4<br>5<br>3, 4 和 5 中最大的数为 5</p>
<p>6.6, 8.8 和 7.7 中最大的数为 8.8</p>
<p>pear, apple 和 orange 中最大的数为 pear<br>泛型类<br>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。</p>
<p>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p>
<p>实例</p>
<p>如下实例演示了我们如何定义一个泛型类:</p>
<p>实例<br>public class Box { private T t; public void add(T t) { this.t = t; } public T get() { return t; } public static void main(String[] args) { Box integerBox = new Box(); Box stringBox = new Box(); integerBox.add(new Integer(10)); stringBox.add(new String(“菜鸟教程”)); System.out.printf(“整型值为 :%d\n\n”, integerBox.get()); System.out.printf(“字符串为 :%s\n”, stringBox.get()); } }</p>
<p>编译以上代码，运行结果如下所示：</p>
<p>1<br>2<br>3<br>整型值为 :10</p>
<p>字符串为 :菜鸟教程<br>类型通配符<br>1、类型通配符一般是使用?代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List,List 等所有List&lt;具体类型实参&gt;的父类。</p>
<p>实例<br>import java.util.*; public class GenericTest { public static void main(String[] args) { List name = new ArrayList(); List age = new ArrayList(); List number = new ArrayList(); name.add(“icon”); age.add(18); number.add(314); getData(name); getData(age); getData(number); } public static void getData(List&lt;?&gt; data) { System.out.println(“data :” + data.get(0)); } }</p>
<p>输出结果为：</p>
<p>1<br>2<br>3<br>data :icon<br>data :18<br>data :314<br>解析： 因为getData()方法的参数是List类型的，所以name，age，number都可以作为这个方法的实参，这就是通配符的作用</p>
<p>2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p>
<p>实例<br>import java.util.*; public class GenericTest { public static void main(String[] args) { List name = new ArrayList(); List age = new ArrayList(); List number = new ArrayList(); name.add(“icon”); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 } public static void getData(List&lt;?&gt; data) { System.out.println(“data :” + data.get(0)); } public static void getUperNumber(List&lt;? extends Number&gt; data) { System.out.println(“data :” + data.get(0)); } }</p>
<p>输出结果：</p>
<p>1<br>2<br>data :18<br>data :314<br>解析： 在(//1)处会出现错误，因为getUperNumber()方法中的参数已经限定了参数泛型上限为Number，所以泛型为String是不在这个范围之内，所以会报错</p>
<p>3、类型通配符下限通过形如 List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型，如 Object 类型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/06/java%E6%B3%9B%E5%9E%8B/" data-id="ck2n6r2u200042oca8286chuo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/11/06/AJAX%E7%AE%80%E4%BB%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          AJAX简介
        
      </div>
    </a>
  
  
    <a href="/2019/11/06/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">安卓开发环境搭配</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/06/java%E9%9D%A2%E8%B1%A1%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/">java面象对象总结</a>
          </li>
        
          <li>
            <a href="/2019/11/06/AJAX%E7%AE%80%E4%BB%8B/">AJAX简介</a>
          </li>
        
          <li>
            <a href="/2019/11/06/java%E6%B3%9B%E5%9E%8B/">java泛型</a>
          </li>
        
          <li>
            <a href="/2019/11/06/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/">安卓开发环境搭配</a>
          </li>
        
          <li>
            <a href="/2019/11/06/JDK-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">JDK 开发环境配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>